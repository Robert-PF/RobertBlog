<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java 面试题整理笔记 | Robert Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、说一说虚拟地址空间有哪些部分：用户空间、内核空间、栈空间、堆空间、代码段、BSS段、DATA段 32位系统中，虚拟地址空间为 0 ~ 4G，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间，虚拟地址空间分布如下图：  内核">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 面试题整理笔记">
<meta property="og:url" content="https://robert-pf.github.io/RobertBlog/2022/04/12/%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Robert Blog">
<meta property="og:description" content="1、说一说虚拟地址空间有哪些部分：用户空间、内核空间、栈空间、堆空间、代码段、BSS段、DATA段 32位系统中，虚拟地址空间为 0 ~ 4G，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间，虚拟地址空间分布如下图：  内核">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//02B0D093C76FDC4C79EF2939FA3217C0.png">
<meta property="og:image" content="https://www.nowcoder.com/interview/ai/img/001-1.11.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220730203215842-16591843483961.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220731000415283-16591970797482.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220809224555503-16600563587151.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220809224625746-16600563876112.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220809225239901-16600567619823.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220811002228002-16601485500451.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220813192626832-16603899882524.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220813202843304-16603937252815.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220813203136164-16603938985386.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220813214806502-16603984884347.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220814120938172-16604501798318.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220815004202921-166049532581710.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeXVlX2h1,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.png">
<meta property="og:image" content="https://robert-pf.github.io/RobertBlog/.io//image-20220816004015828-16605816171142.png">
<meta property="article:published_time" content="2022-04-11T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-16T11:06:12.920Z">
<meta property="article:author" content="Robert Pang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://robert-pf.github.io/RobertBlog/.io//02B0D093C76FDC4C79EF2939FA3217C0.png">
  
    <link rel="alternate" href="/RobertBlog/atom.xml" title="Robert Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/RobertBlog/css/style.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/RobertBlog/" id="logo">Robert Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/RobertBlog/">Home</a>
        
          <a class="main-nav-link" href="/RobertBlog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/RobertBlog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://robert-pf.github.io/RobertBlog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/RobertBlog/2022/04/12/%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-04-11T16:00:00.000Z" itemprop="datePublished">2022-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java 面试题整理笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、说一说虚拟地址空间有哪些部分："><a href="#1、说一说虚拟地址空间有哪些部分：" class="headerlink" title="1、说一说虚拟地址空间有哪些部分："></a>1、说一说虚拟地址空间有哪些部分：</h3><p>用户空间、内核空间、栈空间、堆空间、代码段、BSS段、DATA段</p>
<p>32位系统中，虚拟地址空间为 0 ~ 4G，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间，虚拟地址空间分布如下图：<br><img src="/RobertBlog/.io//02B0D093C76FDC4C79EF2939FA3217C0.png" alt="图片说明"><br><img src="https://www.nowcoder.com/interview/ai/img/001-1.11.png" alt="img"></p>
<ol>
<li><p>内核空间</p>
<p>存放内核的代码和数据，所有进程的内核代码段都映射到同样的物理内存，并在内存中持续存在，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</p>
</li>
<li><p>用户空间</p>
<p>用户空间给各个进程使用，也称为使用者空间。用户空间中的代码运行在较低的特权级别上，只能看到允许它们使用的部分系统资源，并且不能使用某些特定的系统功能，也不能直接访问内核空间和硬件设备，以及其他一些具体的使用限制。用户空间又大致细分为下列一些空间：</p>
<ul>
<li>栈空间</li>
<li>共享区</li>
<li>堆空间</li>
<li>BSS 段（未初始化数据段）</li>
<li>DATA 段（已初始化数据段）</li>
<li>TEXT 段（代码段）</li>
<li>保留区</li>
</ul>
</li>
</ol>
<h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p>用户空间：</p>
<ol>
<li><p>栈空间</p>
<p>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈（先进后出）。存储局部变量、函数参数值。栈从高地址向低地址增长，是一块连续的空间。</p>
</li>
<li><p>共享区</p>
<p>内存映射以及共享库（动态库）所在的内存。</p>
</li>
<li><p>堆空间</p>
<p>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。堆从低地址向高地址增长。通过 new() 或者 malloc() 函数可以在堆区开辟空间。</p>
</li>
<li><p>BSS 段（未初始化数据段）</p>
<p>BSS（Block Started by Symbol）段中通常存放程序中以下符号：</p>
<ul>
<li>未初始化的全局变量和静态局部变量</li>
<li>初始值为 0 的全局变量和静态局部变量(依赖于编译器实现)</li>
</ul>
</li>
<li><p>DATA 段（已初始化数据段）</p>
<p>数据段通常用于存放程序中已初始化且初值不为 0 的全局变量和静态局部变量。</p>
</li>
<li><p>TEXT 段（代码段）</p>
<p>代码段也称正文段或文本段，通常用于存放程序执行代码（即CPU执行的机器指令）。</p>
</li>
<li><p>保留区</p>
<p>位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。</p>
</li>
</ol>
<h3 id="2、MySQL的事务隔离级别："><a href="#2、MySQL的事务隔离级别：" class="headerlink" title="2、MySQL的事务隔离级别："></a>2、MySQL的事务隔离级别：</h3><p>脏读：一个事务读取另一个还未提交的事务修改的数据。</p>
<p>丢失修改：两个事务都对数据做了修改，但是还未提交，导致两次修改都是基于还未修改的做的操作，其中有一个事务的修改会丢失。</p>
<p>不可重复读：两次读取到的数不一样。</p>
<ul>
<li>读未提交：允许读取未提交的事务，mysql的最低隔离级别，可能</li>
<li>读已提交：允许读取</li>
<li>可重复读</li>
<li>串行</li>
</ul>
<h3 id="3、面向对象和面向过程"><a href="#3、面向对象和面向过程" class="headerlink" title="3、面向对象和面向过程"></a>3、面向对象和面向过程</h3><p>面向对象和面向过程注重点不一定样，面向过程围绕的是整个流程需要怎么设计，面向对象主要是将行为抽取未对象的特征或者功能，后期再再让对象执行流程。</p>
<p>面向对象最大的三个特性是，封装、继承、多态。封装是为了</p>
<h3 id="4、https1-0和2-0的区别"><a href="#4、https1-0和2-0的区别" class="headerlink" title="4、https1.0和2.0的区别"></a>4、https1.0和2.0的区别</h3><h3 id="5、重载和重写的区别"><a href="#5、重载和重写的区别" class="headerlink" title="5、重载和重写的区别"></a>5、重载和重写的区别</h3><p>重载是发生在同一个类中，方法名相同，参数类型、顺序、个数不一致；方法返回值、和权限修饰符可以不一样。</p>
<p>重写是子类重写父类的方法，方法名、参数类型必须一致；返回值和类型、抛出异常范围必须小于父类。访问修饰符必须大于等于父类。</p>
<h3 id="6、List-Set区别"><a href="#6、List-Set区别" class="headerlink" title="6、List Set区别"></a>6、List Set区别</h3><p>List 是有序可重复，存储顺序是按照添加元素的顺序存储得，可以有多个null值。可以使用迭代器和get（index i）的方法获得对象。</p>
<p>Set 存储的是无序和不可重复的、存储位置根据数据的hash值进行映射存储。只能用迭代器进行遍历查找。</p>
<h3 id="7、ConcurrentHashMap扩容机制："><a href="#7、ConcurrentHashMap扩容机制：" class="headerlink" title="7、ConcurrentHashMap扩容机制："></a>7、ConcurrentHashMap扩容机制：</h3><p>1.7版本：</p>
<ul>
<li>采用的是分段数组+链表实现。基于Segment分段实现的。</li>
<li>每个Segment相当于一个小型的HashMap。</li>
<li>每个Segment内部会进行扩容，和Hashmap的扩容逻辑类似。</li>
<li>先生成新的数据，然后转移元素到新的数组中。</li>
<li>扩容的判断也是每个Segment内部单独判断，判断是否超过阈值。</li>
</ul>
<p>1.8版本：</p>
<ul>
<li>采用的是数组+链表/红黑树实现的</li>
<li>当某个线程进行put操作时，如果发现ConcurrentHashMap正在进行扩容，那么该线程一起进行扩容。</li>
<li>ConcurrentHashMap是支持多线程进行扩容。</li>
<li>如果缪个线程put是，发现没有进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容。</li>
<li>扩容之前也是先生成一个新的数组。</li>
<li>在愿意元素是，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或者多组元素的转移。</li>
</ul>
<h3 id="8、1-7-1-8-HashMap的变化"><a href="#8、1-7-1-8-HashMap的变化" class="headerlink" title="8、1.7-1.8 HashMap的变化"></a>8、1.7-1.8 HashMap的变化</h3><p>1.7 数组+链表 1.8 数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询的整体效率。</p>
<p>1.7链表使用的是头插法，1.8链表使用的尾插法。因为1.8插入key和value时需要判断链表元素的个数，所以需要遍历链表元素的个数，所以正好使用尾插法。</p>
<p>1.7 哈希算法存在左移和右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红荷数，可以适当的简化hash算法，节省CPU资源。</p>
<h3 id="9、-HashMap的put方法"><a href="#9、-HashMap的put方法" class="headerlink" title="9、 HashMap的put方法"></a>9、 HashMap的put方法</h3><p>1、根据key通过hash算法和与运算得出数组下标。</p>
<p>2、数组下标为空，将key和value封装为Entry对象（1.8 时Node对象）并放入该位置。</p>
<p>3、如果数组下标位置元素不为空，则要分情况讨论：</p>
<ol>
<li>1.7先判断是否扩容，需要扩容就先扩容，如果不需要扩容就先生成Entry对象，使用头插法添加到当前位置的链表中。</li>
<li>1.8 先判断当前位置上的Node的类型，<ol>
<li>红黑树，将对象添加到红黑树中或者更新红黑树的value</li>
<li>链表节点，先尾插或者更新key-value，再判断是否满足转换成红黑树的条件。</li>
<li>将key-value封装为Node或者红黑树后，再判断是否需要进行扩容，如果需要扩容，就进行扩容，如果不需要的话就结束put方法。</li>
</ol>
</li>
</ol>
<h3 id="10、深拷贝和浅拷贝"><a href="#10、深拷贝和浅拷贝" class="headerlink" title="10、深拷贝和浅拷贝"></a>10、深拷贝和浅拷贝</h3><p>浅拷贝的只拷贝基本数据类型和引用</p>
<p>深拷贝时将涉及到的对象的数据进行全部尽心拷贝。</p>
<h3 id="11、HashMap的扩容机制。"><a href="#11、HashMap的扩容机制。" class="headerlink" title="11、HashMap的扩容机制。"></a>11、HashMap的扩容机制。</h3><p>1.7 版本</p>
<ol>
<li>​    先生成新数组</li>
<li>遍历老数组中的元素</li>
<li>取出key ，基于新数组长度，计算每个元素在新数组中的下标。</li>
<li>将元素添加到新数组中</li>
<li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性。</li>
</ol>
<p>1.8版本</p>
<ol>
<li>先生成新数组</li>
<li>遍历老数组</li>
<li>如果是链表，则将链表中的每个元素重新计算下标，添加到新数组中</li>
<li>如果是红黑树，先遍历红黑树，计算出红黑树中每个元素对应在新数组中的下标位置。<ol>
<li>统计每个下标的元素个数，如果该下标位置元素个数超过8生成红黑树，负责已链表形式插入数组中。</li>
</ol>
</li>
<li>所有元素转移完之后，将新数组复制给HashMap对象的table属性。</li>
</ol>
<h3 id="12、CopyOnWriteArrayList的原理："><a href="#12、CopyOnWriteArrayList的原理：" class="headerlink" title="12、CopyOnWriteArrayList的原理："></a>12、CopyOnWriteArrayList的原理：</h3><p>可以实现多并发，读多写少，对实时性要求不高的情况。</p>
<p>原理：在一个线程读数据的时候，另一个线程有写的情况，会先将数组复制一份出来，并且加锁防止并发写入，在新的数组上进行写操作，读操作还是在原数组上进行。当写操作完成时，会释放锁，并且将原数组指向新的数组。</p>
<h3 id="13、什么是字节码，字节码的好处"><a href="#13、什么是字节码，字节码的好处" class="headerlink" title="13、什么是字节码，字节码的好处"></a>13、什么是字节码，字节码的好处</h3><p>字节码是java源文件编译后的文件，编译后的文件的话可以跨平台运行。编译后的文件，也会提高代码的执行性能。</p>
<h3 id="14、java中的异常体系是什么"><a href="#14、java中的异常体系是什么" class="headerlink" title="14、java中的异常体系是什么"></a>14、java中的异常体系是什么</h3><p>java中的所有异常的父类是Throwable.</p>
<p>Throwable 分为两类 erro 和exception：erro是java虚拟机比价严重的错误比如堆栈溢出，通常这些报错是靠程序自身是无法解决的，Error不能在程序运行过程中被动态处理，一旦出现Error，系统能做的只有记录错误的原因和安全终止。</p>
<p>exception 在运行中的程序发生了程序员不期望发生的事情，可以被Java异常处理机制处理。分为RuntimeException和非RuntimeException</p>
<ol>
<li>RuntimeException是运行时异常，需要在运行的时候后可以产生的异常：</li>
<li>非RuntimeException就是Exception类中除运行类异常之外的异常，如果不处理这类异常，程序都无法编译通过，例如io异常和sql异常。</li>
</ol>
<h3 id="15、什么样的类能被回收"><a href="#15、什么样的类能被回收" class="headerlink" title="15、什么样的类能被回收"></a>15、什么样的类能被回收</h3><ol>
<li>改类所有的对象实例都已被回收，java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的Java.lang.Class 对象没有在二年和地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<h3 id="16、JVM-垃圾收集算法"><a href="#16、JVM-垃圾收集算法" class="headerlink" title="16、JVM 垃圾收集算法"></a>16、JVM 垃圾收集算法</h3><ol>
<li>复制算法：只能利用一半的空间。</li>
<li>标记清除算法：内存碎片化严重，标记比较多的时候，效率比较低。</li>
<li>标记整理算法：</li>
</ol>
<h3 id="17、解释JVM内部各种垃圾收集算法："><a href="#17、解释JVM内部各种垃圾收集算法：" class="headerlink" title="17、解释JVM内部各种垃圾收集算法："></a>17、解释JVM内部各种垃圾收集算法：</h3><ol>
<li>分带收集理论：Java 堆分为新生代和老年代。新生代朝生夕死，可以采用复制算法完成垃圾收集。老年代对象的存活率较高，采用标记清除和标记整理算法比较合适，但是标记清理和标记清除算法比复制算法慢10倍以上。</li>
<li></li>
</ol>
<h3 id="18、解释下CMS收集器垃圾收集过程"><a href="#18、解释下CMS收集器垃圾收集过程" class="headerlink" title="18、解释下CMS收集器垃圾收集过程"></a>18、解释下CMS收集器垃圾收集过程</h3><p>三色标记</p>
<p>三色标记产生的漏标问题怎么解决：</p>
<p>增量更新和原始快照方法解决的：增量更新是如果有新的</p>
<h3 id="19、G1垃圾回收器过程"><a href="#19、G1垃圾回收器过程" class="headerlink" title="19、G1垃圾回收器过程"></a>19、G1垃圾回收器过程</h3><h3 id="20、G1垃圾收集器最大的停顿时间是如何实现的"><a href="#20、G1垃圾收集器最大的停顿时间是如何实现的" class="headerlink" title="20、G1垃圾收集器最大的停顿时间是如何实现的"></a>20、G1垃圾收集器最大的停顿时间是如何实现的</h3><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的region，每一个region会估算回收需要的时间。在回收时间有限的情况下，会选用回收效率最高效的区域进行回收。</p>
<h3 id="21、内存泄漏到底是怎么回事，怎么快速排查"><a href="#21、内存泄漏到底是怎么回事，怎么快速排查" class="headerlink" title="21、内存泄漏到底是怎么回事，怎么快速排查"></a>21、内存泄漏到底是怎么回事，怎么快速排查</h3><p>一般的电商架构可能会使用多级缓存架构，就是Redis加上JVM级缓存，当JVM级缓存直接用了hashMap，于是不断往里边放数据的过程中，缓存mao越来越大，时间长了就会导致full gc非常频繁，这就是一种内存泄漏。时间长了可能还会导致OOM。</p>
<p>这种情况完全可以考虑采用一些成熟的JVM级缓存框架来解决，比如ehcache邓自带的一些LRU数据淘汰算法的框架来作为JVM级的缓存。</p>
<h3 id="22、GC是什么时候都能做得吗？知道GC安全点与安全区域是怎么回事？"><a href="#22、GC是什么时候都能做得吗？知道GC安全点与安全区域是怎么回事？" class="headerlink" title="22、GC是什么时候都能做得吗？知道GC安全点与安全区域是怎么回事？"></a>22、GC是什么时候都能做得吗？知道GC安全点与安全区域是怎么回事？</h3><p>GC不是任何时候都能做得，需要代码运行到安全点或安全区域才能做。</p>
<p>安全点：代码中的一些特定的位置，当线程运行到这些位置时，他的状况时确定的，这样JVM就可以安全的进行一些操作，比如GC，所以GC是需要等待所有的线程运行到安全点之后才能触发。</p>
<p>这些特定的安全位置主要有以下几种：</p>
<ol>
<li>方法返回之前</li>
<li>调用某个方法之后</li>
<li>抛出异常的位置</li>
<li>循环的末尾</li>
</ol>
<p>大体实现思想时，当垃圾收集器需要中断线程的时候，不直接对线程做操作，仅简单的设置一个标志位，各个线程执行过中会检查自己是否运行到这个标志位，如果到了的话，自己主动挂起。</p>
<p>安全区域：安全点时对于正在执行的线程设定的，如果一个线程处于sleep状态或者中断状态，他就不能相应jvm的终端请求，再运行到安全点。因此JVM引入了安全区域，是指一段代码片中，引用关系不会发生变化，在这个区域内的任意地方，开始GC是安全的。</p>
<h3 id="22、解析下字符串常量池："><a href="#22、解析下字符串常量池：" class="headerlink" title="22、解析下字符串常量池："></a>22、解析下字符串常量池：</h3><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="15、Spring创建对象bean的流程"><a href="#15、Spring创建对象bean的流程" class="headerlink" title="15、Spring创建对象bean的流程"></a>15、Spring创建对象bean的流程</h3><p>UserService类–&gt;推断构造方法（推断构造方法，可以用无参或者有参的）–&gt;对象—&gt;依赖注入</p>
<p>–&gt;初始化前（@PostConstruct 找到类中有此注解的方法执行）</p>
<p>–&gt;初始化（InitializingBean）–&gt;初始化后（AOP）–&gt;代理对象–&gt;放入Map单例池中—&gt;bean对象</p>
<h4 id="16、推断构造方法是什么？"><a href="#16、推断构造方法是什么？" class="headerlink" title="16、推断构造方法是什么？"></a>16、推断构造方法是什么？</h4><ul>
<li><p>UserService类–无参构造方法</p>
<ul>
<li><p>一个类中如果有多个构造方法的情况下，默认会用无参构造方法进行实例化实例。</p>
</li>
<li><p>如果有多个构造方法并且没有无参构造方法的情况下，会去寻找构造方法中是否有@Autowired这个注解，如果有的话，会使用此构造方法。</p>
</li>
</ul>
</li>
</ul>
<p>在使用构造方法创建实例的过程中，会使用先byType，再byName的方式传入Bean。例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(OrderService orderService1)</span>&#123;</span><br><span class="line">    system.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述构造方法中有一个orderservice的bean需要传入，spring会现根据OrderService寻找Map中寻找是否有类为OrderService类的Bean，如果有且只有一个的时候，就用此Bean；如果有多个情况下，会根绝orderService1这个名字寻找到对应的Bean并传入。</p>
<ul>
<li>总结 先ByType 后ByName。</li>
</ul>
<h4 id="17、依赖注入过程"><a href="#17、依赖注入过程" class="headerlink" title="17、依赖注入过程"></a>17、依赖注入过程</h4><ul>
<li>也是先ByType，后ByName。</li>
</ul>
<h4 id="18、动态代理"><a href="#18、动态代理" class="headerlink" title="18、动态代理"></a>18、动态代理</h4><p><img src="/RobertBlog/.io//image-20220730203215842-16591843483961.png" alt="image-20220730203215842"></p>
<h3 id="19、注解失效"><a href="#19、注解失效" class="headerlink" title="19、注解失效"></a>19、注解失效</h3><p>直接在一个事务中执行开了注解的另外一个方法，方法a的注解会失效。</p>
<p><img src="/RobertBlog/.io//image-20220731000415283-16591970797482.png" alt="image-20220731000415283"></p>
<h2 id="20、-Configuration的作用"><a href="#20、-Configuration的作用" class="headerlink" title="20、@Configuration的作用"></a>20、@Configuration的作用</h2><ol>
<li>告诉spring这是一个配置类，相当于spring的xml配置文件</li>
<li>被@Configuration 注解的类，会被cglib代理进行增强</li>
<li>@Conﬁguration类允许通过调用同一类中的其他@Bean方法来定义bean之间的依赖关系，保证@Bean的对象作用域受到控制，避免多例</li>
</ol>
<h2 id="21、为什么要用三级缓存，解决循环依赖问题？"><a href="#21、为什么要用三级缓存，解决循环依赖问题？" class="headerlink" title="21、为什么要用三级缓存，解决循环依赖问题？"></a>21、为什么要用三级缓存，解决循环依赖问题？</h2><ul>
<li>类名前两个字母是大写的情况下 ABService下，spring中对应的Bean的Name是AService，如果是Abservice ，spring中bean容器中的name是abservice。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Compan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AService</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22、-Async-会-导致循坏依赖失败"><a href="#22、-Async-会-导致循坏依赖失败" class="headerlink" title="22、@Async 会 导致循坏依赖失败"></a>22、@Async 会 导致循坏依赖失败</h2><h2 id="23、构造方法何何多实例导致循环依赖失败"><a href="#23、构造方法何何多实例导致循环依赖失败" class="headerlink" title="23、构造方法何何多实例导致循环依赖失败"></a>23、构造方法何何多实例导致循环依赖失败</h2><ul>
<li>​    构造方法传入了相互依赖的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ASeervice&#123;</span><br><span class="line">    <span class="keyword">private</span> Bservice bService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AService</span><span class="params">(BServive bService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bService=bService</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Class BSeervice&#123;</span><br><span class="line">    <span class="keyword">private</span> Aservice aService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BService</span><span class="params">(AServive aService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bService=bService</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多实例导致失败</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Class ASeervice&#123;</span><br><span class="line">    <span class="keyword">private</span> Bservice bService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AService</span><span class="params">(BServive bService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bService=bService</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Class BSeervice&#123;</span><br><span class="line">    <span class="keyword">private</span> Aservice aService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BService</span><span class="params">(AServive aService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bService=bService</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Web容器</p>
<p>Tomcat、Jetty、Undertow</p>
<p>自动选择使用什么容器的原理</p>
<p><img src="/RobertBlog/.io//image-20220809224555503-16600563587151.png" alt="image-20220809224555503"></p>
<p><img src="/RobertBlog/.io//image-20220809224625746-16600563876112.png" alt="image-20220809224625746"></p>
<h2 id="ConditionalOnClass注解"><a href="#ConditionalOnClass注解" class="headerlink" title="@ConditionalOnClass注解"></a>@ConditionalOnClass注解</h2><p><img src="/RobertBlog/.io//image-20220809225239901-16600567619823.png" alt="image-20220809225239901"></p>
<p>ASM util获取class文件的注解信息。</p>
<p>BeanPostProcess</p>
<h1 id="Mysql："><a href="#Mysql：" class="headerlink" title="Mysql："></a>Mysql：</h1><p>B树和B+树的区别：</p>
<p>B树，一个节点可能会有多个</p>
<p>数据库中字符类型转换：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,var e, index <span class="keyword">on</span> a,e;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span>; #能走索引查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;#能走索引查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> e<span class="operator">=</span><span class="number">1</span>;#不能走索引查询，因为此条件中 e是<span class="type">varchar</span>类型，在与<span class="number">1</span>最比较的时候，会先将e转换成<span class="type">int</span> <span class="number">0</span>,所以查询不出结果。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> e<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;#能走索引查询</span><br><span class="line">#不是数字的字符，在查询时，如果用判断e的的值的时候会将e转换成<span class="number">0</span>；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>索引：</p>
<table>
<thead>
<tr>
<th>Memory存储引擎</th>
<th>Hash索引</th>
<th>不支持排序<br>不支持部分列索引查找<br>只支持等值查询，无法提供范围查询功能</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>B 树</td>
<td>优秀检索速度<br>尽可能少的磁盘 IO，加快了检索速度；<br>可以支持范围查找。</td>
</tr>
<tr>
<td>Innodb 作为存储引擎<br>myisam 作为存储引擎</td>
<td>B+Tree</td>
<td>非叶子节点不存储data,只存储索引(冗余),可以放更多的索引 <br>叶子节点包含所有索引字段<br>叶子节点用双向指针相连，提高区间访问性</td>
</tr>
</tbody></table>
<h2 id="innodb和myisam的区别"><a href="#innodb和myisam的区别" class="headerlink" title="innodb和myisam的区别"></a>innodb和myisam的区别</h2><ul>
<li>innodb支持事务，而myisam不支持事务。Myisam不支持事务原因索引与数据分开存储，两个文件无法做到一致性。</li>
<li>innodb支持外键，而myisam不支持外键。</li>
<li>innodb默认表锁，使用索引检索条件时是行锁，而myisam是表锁（每次更新增加删除都会锁住表）。</li>
<li>innodb和myisam的索引都是基于b+树，但他们具体实现不一样，innodb的b+树的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020">叶子节点</a>是存放数据的，myisam的b+树的叶子节点是存放指针的。</li>
<li>innodb是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020">聚簇索引</a>，必须要有主键，一定会基于主键查询，但是辅助索引就会查询两次，myisam是非聚簇索引，索引和数据是分离的，索引里保存的是数据地址的指针，主键索引和辅助索引是分开的。</li>
<li>innodb不存储表的行数，所以select count( * )的时候会全表查询，而myisam会存放表的行数，select count(*）的时候会查的很快。</li>
</ul>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul>
<li>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站，存储操作日志。</li>
<li>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如 OA自动化办公系统。</li>
</ul>
<h4 id="数据存储形式"><a href="#数据存储形式" class="headerlink" title="数据存储形式"></a>数据存储形式</h4><ul>
<li>聚集索引（聚簇索引）形式：索引和数据是否存在放一起，即B+tree中的叶子节点存储的是实际数据；</li>
<li>非聚集索引（非聚簇索引）：索引存放的是数据的一个指针，可以是主键，也可以是数据的地址值。</li>
</ul>
<ol>
<li>Mysql的innodb引擎：是利用B++树以聚簇索引的形式实现存放数据，表中的非聚簇索引（二级索引）存放的是数据的的主键值。一个Innodb只能有一个聚簇索引，可以有多个二级索引。<ul>
<li><strong>聚簇索引建立的列规则</strong>，按照优先级为：主键-&gt;第一个非空唯一列-&gt;InnoDB创建一个隐式row-id作为聚簇索引</li>
</ul>
</li>
<li>MyISAM存储引擎：是利用B+树以非聚簇索引的形式实现存放数据。索引和数据是分开存放的，索引的叶子节点存储的是数据行的地址。<code>MyISAM</code> 引擎按照数据插入顺序，将数据文件存储在磁盘上.</li>
</ol>
<h4 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询:"></a>回表查询:</h4><ul>
<li>就是根据非聚簇索引，查找到主键值，再根据主键值去表中取数据的过程就叫做回表。</li>
<li>innodb中回表一般是出现利用非聚簇索引查询时，需要返回的数据不在索引中会出需要回表进行取值操作。</li>
<li>Myisam检索数据过程中有 “回表操作”，因为myisam的索引是非聚簇索引，利用索引只能查询到数据中对应的行的地址。</li>
</ul>
<h4 id="索引覆盖："><a href="#索引覆盖：" class="headerlink" title="索引覆盖："></a>索引覆盖：</h4><p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫做索引覆盖。 实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。</p>
<p>Inodb查询等于的查询 引擎会自动使用哈希索引进行查询,存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应哈希索引。自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。而且不需要将整个表都建哈希索引，InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>复合索引使用时遵循最左前缀原则，最左前缀顾名思义，就是最左优先，即查询中使用到最左边的列，那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效。</p>
<p><img src="/RobertBlog/.io//image-20220811002228002-16601485500451.png" alt="image-20220811002228002"></p>
<p>对字段进行操作会导致联合索引失效；</p>
<h2 id="MySQL在使用like模糊查询时，索引能不能起作用？"><a href="#MySQL在使用like模糊查询时，索引能不能起作用？" class="headerlink" title="MySQL在使用like模糊查询时，索引能不能起作用？"></a>MySQL在使用like模糊查询时，索引能不能起作用？</h2><p>回答：MySQL在使用Like模糊查询时，索引是可以被使用的，只有把%字符写在后面才会使用到索引。 select * from user where name like ‘%o%’; //不起作用 select * from user where name like ‘o%’; //起作用 select * from user where name like ‘%o’; //不起作用</p>
<h2 id="MySQL查询支持filesort和index两种方式的排序"><a href="#MySQL查询支持filesort和index两种方式的排序" class="headerlink" title="MySQL查询支持filesort和index两种方式的排序"></a>MySQL查询支持filesort和index两种方式的排序</h2><p>filesort是先把结果查出，然后在缓存或磁盘进行排序操作，效率较低。使用index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。 <strong>filesort有两种排序算法：双路排序和单路排序。</strong> <strong>双路排序</strong>：需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序；第二次去读取其他字段数据。 <strong>单路排序</strong>：从磁盘查询所需的所有列数据，然后在内存排序将结果返回。如果查询数据超出缓存 sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。 解决方案：少使用select *；增加sort_buffer_size容量和max_length_for_sort_data容量。</p>
<p>如果我们Explain分析SQL，结果中Extra属性显示Using filesort，表示使用了filesort排序方式，需要优 化。如果Extra属性显示Using index时，表示覆盖索引，也表示所有操作在索引上完成，也可以使用 index排序方式，建议尽可能采用覆盖索引。</p>
<h2 id="Mysql索引失效的情况"><a href="#Mysql索引失效的情况" class="headerlink" title="Mysql索引失效的情况"></a>Mysql索引失效的情况</h2><ul>
<li>围查询右边的列，不能使用索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> status <span class="operator">&gt;</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span></span><br></pre></td></tr></table></figure>

<p>前面的两个字段name，status查询是走索引的，都是最后一个条件address没有用到索引</p>
<ul>
<li>不要在索引列上进行运算操作，索引将失效</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">3</span>,<span class="number">2</span>)<span class="operator">=</span><span class="string">&#x27;科技&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串不加单引号，造成索引失效</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> status <span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用or分隔的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">or</span> createtime<span class="operator">=</span><span class="string">&#x27;2020-04-05 12:00:00&#x27;</span></span><br></pre></td></tr></table></figure>

<p>name是索引列，createtime不是索引列，之间or进行连接，那么会导致name列也不走索引</p>
<ul>
<li>以%开头的like模糊查询，索引失效</li>
</ul>
<p>如果仅仅是尾部的模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效，但是如果使用覆盖索引，那么索引仍然会生效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%test&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果MySql评估使用索引比全表扫描更慢，则不使用索引</p>
</li>
<li><p>is null，is not null 有时索引失效</p>
</li>
<li><p>in 走索引，not in 索引失效</p>
</li>
<li><p>使用不等于(!=或者&lt;&gt;)的时候，索引失效，会导致全表扫描</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="operator">!=</span> <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MYSQL针对函数或存储过程中传递进的参数,如果是varchar类型时则默认会进行转换字符集校对规则与数据库保持一致，这个时候如果数据库编码和表编码不一致时（比如utf8和utf8mb4），就会出现索引失效的情况</li>
</ul>
<h2 id="最佳索引使用策略"><a href="#最佳索引使用策略" class="headerlink" title="最佳索引使用策略"></a>最佳索引使用策略</h2><ul>
<li>对查询频次较高,且数据量比较大的表建立索引</li>
<li>索引字段的选择,最佳候选列应当从 where子句的条件中提取,如果where子句中的组合比较多,那么应当挑选最常用、过滤效果最好的列的组合</li>
<li>索引可以有效的提升查询数据的效率,但索引数昰不是多多益善,索引越多,维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说,索引过多,会引入相当高的维护代价,降低DM操作的效率,增加相应操作的时间消耗。另外索引过多的话, MySQL也会犯选择困难病,虽然最终仍然会找到一个可用的索引,但无疑提高了选择的代价</li>
<li>独立的列</li>
</ul>
<p>独立的列不是指单列索引，而是指索引列不能是表达式的一部分或者是函数的一部分。</p>
<p>select * FROM test where col1 + 1 =100; // 不能是表达式一部分</p>
<p>select * FROM test where ABS(col1) =100; // 不能是函数一部分</p>
<ul>
<li>最左匹配原则</li>
</ul>
<p>假如有个联合索引 key (col1,col2)。那么以下查询是索引无效的</p>
<p>select * from test where col2 = 3;</p>
<p>select * from test where col1 like ‘%3’;</p>
<p>对于最左匹配原则，大家想一下B+树的叶子节点的关联就差不多知道为啥需要最左匹配原则了，因为B+的叶子结点，从左到右以链表的形式关联的，索引我们查询的时候要么范围查询，<strong>要么有明确的左边一个开始的索引值</strong>，不能跳过或者不明确如 like ‘%XYZ’这种查询。</p>
<p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 <code>col2= xx and col1 ＝xx</code>，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的</p>
<ul>
<li>使用聚簇索引和覆盖索引大大提升读取性能</li>
</ul>
<p>因为聚簇索引和覆盖索引的索引树上就有了需要的字段，所以不需要回表文件查询，所以提升了查询速度</p>
<ul>
<li>使用短索引</li>
</ul>
<p>如果很长的字符串进行查询，只需匹配一个前缀长度，这样能够节省大量索引空间</p>
<ul>
<li>尽量使用覆盖索引，避免使用select *</li>
</ul>
<h2 id="说说Redis"><a href="#说说Redis" class="headerlink" title="说说Redis"></a>说说Redis</h2><p>Redis主要提供了5种数据结构：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)。Redis还提供了Bitmap、HyperLogLog、Geo类型,但这些类型都是基于上述核心数据类型实现的。5.0版本中,Redis新增加了Streams数据类型,它是一个功能强大的、支持多播的、可持久化的消息队列。 string可以存储字符串、数字和二进制数据,除了值可以是String以外,所有的键也可以是string,string最大可以存储大小为2M的数据。 list保证数据线性有序且元素可重复,它支持lpush、blpush、rpop、brpop等操作,可以当作简单的消息队列使用,一个list最多可以存储2^32-1个元素 hash的值本身也是一个键值对结构,最多能存储2^32-1个元素 set是无序不可重复的,它支持多个set求交集、并集、差集,适合实现共同关注之类的需求,一个set最多可以存储2^32-1个元素 zset是有序不可重复的,它通过给每个元素设置一个分数来作为排序的依据,一个zset最多可以存储2^32-1个元素。 加分回答 每种类型支持多个编码,每一种编码采取一个特殊的结构来实现 各类数据结构内部的编码及结构： string：编码分为int、raw、embstr；int底层实现为long,当数据为整数型并且可以用long类型表示时可以用long存储；embstr底层实现为占一块内存的SDS结构,当数据为长度不超过32字节的字符串时,选择以此结构连续存储元数据和值；raw底层实现为占两块内存的SDS,用于存储长度超过32字节的字符串数据,此时会在两块内存中分别存储元数据和值。 list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）。ziplist底层实现为压缩列表,当元素数量小于2且所有元素长度都小于64字节时,使用这种结构来存储；linkedlist底层实现为双端链表,当数据不符合ziplist条件时,使用这种结构存储；3.2版本之后list一般采用quicklist的快速列表结构来代替前两种。 hash：编码分为ziplist、hashtable两种,其中ziplist底层实现为压缩列表,当键值对数量小于2,并且所有的键值长度都小于64字节时使用这种结构进行存储；hashtable底层实现为字典,当不符合压缩列表存储条件时,使用字典进行存储。 set：编码分为inset和hashtable,intset底层实现为整数集合,当所有元素都是整数值且数量不超过2个时使用该结构存储,否则使用字典结构存储。 zset：编码分为ziplist和skiplist,当元素数量小于128,并且每个元素长度都小于64字节时,使用ziplist压缩列表结构存储,否则使用skiplist的字典+跳表的结构存储。</p>
<h2 id="说说多线程："><a href="#说说多线程：" class="headerlink" title="说说多线程："></a>说说多线程：</h2><p>线程是操作系统调度的最小单元，它可以让一个进程并发地处理多个任务,也叫轻量级进程。所以,在一个进程里可以创建多个线程,这些线程都拥有各自的计数器、堆栈、局部变量,并且能够共享进程内的资源。由于共享资源,处理器便可以在这些线程之间快速切换,从而让使用者感觉这些线程在同时执行。 总的来说,操作系统可以同时执行多个任务,每个任务就是一个进程。进程可以同时执行多个任务,每个任务就是一个线程。一个程序运行之后至少有一个进程,而一个进程可以包含多个线程,但至少要包含一个线程。 使用多线程会给开发人员带来显著的好处,而使用多线程的原因主要有以下几点：</p>
<p> \1. 更多的CPU核心 现代计算机处理器性能的提升方式,已经从追求更高的主频向追求更多的核心发展,所以处理器的核心数量会越来越多,充分地利用处理器的核心则会显著地提高程序的性能。而程序使用多线程技术,就可以将计算逻辑分配到多个处理器核心上,显著减少程序的处理时间,从而随着更多处理器核心的加入而变得更有效率。</p>
<p> \2. 更快的响应时间 我们经常要针对复杂的业务编写出复杂的代码,如果使用多线程技术,就可以将数据一致性不强的操作派发给其他线程处理（也可以是消息队列）,如上传图片、发送邮件、生成订单等。这样响应用户请求的线程就能够尽快地完成处理,大大地缩短了响应时间,从而提升了用户体验。</p>
<ol start="3">
<li>更好的编程模型 Java为多线程编程提供了良好且一致的编程模型,使开发人员能够更加专注于问题的解决,开发者只需为此问题建立合适的业务模型,而无需绞尽脑汁地考虑如何实现多线程。一旦开发人员建立好了业务模型,稍作修改就可以将其方便地映射到Java提供的多线程编程模型上。</li>
</ol>
<h2 id="22、线程和协程的区别？"><a href="#22、线程和协程的区别？" class="headerlink" title="22、线程和协程的区别？"></a>22、线程和协程的区别？</h2><p>协程又称为进程。</p>
<ol>
<li>进程拥有独立的地址空间，线程有自己的堆栈和局部变量，但是线程之间没有单独的地址空间。</li>
<li>进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程的上下文切换时间，耗费资源大，效率差。</li>
<li>进程的并发性比较低，线程的并发性比较高。</li>
<li>每个独立的进程都有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>系统在运行的时候，会为每个进程分配不同的内存空间；但是线程而言，除了CPU之外，系统不会为线程分配内存，只能依赖于所属的进程的的资源，线程组之间只能共享资源。</li>
<li>一个进程崩溃后，在保护模式下不会对其他的进程产生影响，但是一个线程崩溃整个进程都会死掉，所以多进程要比多线程更加健壮。</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Linux 操作系统是采用段页式内存管理方式： 页式存储管理能有效地提高内存利用率（解决内存碎片）,而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来,就形成了段页式存储管理方式。 段页式存储管理方式即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。在段页式系统中,为了实现从逻辑地址到物理地址的转换,系统中需要同时配置段表和页表,利用段表和页表进行从用户地址空间到物理内存空间的映射。 系统为每一个进程建立一张段表,每个分段有一张页表。段表表项中至少包括段号、页表长度和页表始址,页表表项中至少包括页号和块号。在进行地址转换时,首先通过段表查到页表始址,然后通过页表找到页帧号,最终形成物理地址</p>
<h2 id="说说你对IoC的理解"><a href="#说说你对IoC的理解" class="headerlink" title="说说你对IoC的理解"></a>说说你对IoC的理解</h2><p> IoC是控制反转的意思,是一种面向对象编程的设计思想。在不采用这种思想的情况下,我们需要自己维护对象与对象之间的依赖关系,很容易造成对象之间的耦合度过高,在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题,它可以帮我们维护对象与对象之间的依赖关系,并且降低对象之间的耦合度。 说到IoC就不得不说DI,DI是依赖注入的意思,它是IoC实现的实现方式。由于IoC这个词汇比较抽象而DI比较直观,所以很多时候我们就用DI来代替它,在很多时候我们简单地将IoC和DI划等号,这是一种习惯。实现依赖注入的关键是IoC容器,它的本质就是一个工厂。</p>
<p> IoC是Java EE企业应用开发中的就偶组件之间复杂关系的利器。 在以Spring为代表的轻量级Java EE开发风行之前,实际开发中是使用更多的是EJB为代表的开发模式。在EJB开发模式中,开发人员需要编写EJB组件,这种组件需要满足EJB规范才能在EJB容器中运行,从而完成获取事务,生命周期管理等基本服务,Spring提供的服务和EJB并没有什么区别,只是在具体怎样获取服务的方式上两者的设计有很大不同：Spring IoC提供了一个基本的JavaBean容器,通过IoC模式管理依赖关系,并通过依赖注入和AOP切面增强了为JavaBean这样的POJO对象服务于事务管理、生命周期管理等基本功能；而对于EJB,一个简单的EJB组件需要编写远程／本地接口、Home接口和Bean的实体类,而且EJB运行不能脱离EJB容器,查找其他EJB组件也需要通过诸如JNDI的方式,这就造成了对EJB容器和技术规范的依赖。也就是说Spring把EJB组件还原成了POJO对象或者JavaBean对象,以此降低了用用开发对于传统J2EE技术规范的依赖。 在应用开发中开发人员设计组件时往往需要引用和调用其他组件的服务,这种依赖关系如果固化在组件设计中,会造成依赖关系的僵化和维护难度的增加,这个时候使用IoC把资源获取的方向反转,让IoC容器主动管理这些依赖关系,将这些依赖关系注入到组件中,这就会让这些依赖关系的适配和管理更加灵活。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="1、Redis到底是单线程还是多线程？"><a href="#1、Redis到底是单线程还是多线程？" class="headerlink" title="1、Redis到底是单线程还是多线程？"></a>1、Redis到底是单线程还是多线程？</h3><ul>
<li>Redis6.0之前的单线程指的是网络I/O和键值对的读写都是由一个线程完成的。</li>
<li>Redis6.0版本引入了多线程指的是网络请求过程采用了多线程，但是键值对读写命令仍然是采用的单线程，所以Redis依然是并发安全的。</li>
</ul>
<h3 id="2、Redis-单线程为什么还能那么快？"><a href="#2、Redis-单线程为什么还能那么快？" class="headerlink" title="2、Redis 单线程为什么还能那么快？"></a>2、Redis 单线程为什么还能那么快？</h3><ol>
<li> 命令执行基于内存操作</li>
<li>命令执行是单线程，没有线程切换开销</li>
<li>基于IO多路复用机制提升Redis的I\O利用率</li>
<li>高效的数据存储结构，全局Hash表以及多种高效数据结构，比如跳表、压缩列表、链表等。</li>
</ol>
<h3 id="3、Redis-怎么实现跳表的："><a href="#3、Redis-怎么实现跳表的：" class="headerlink" title="3、Redis 怎么实现跳表的："></a>3、Redis 怎么实现跳表的：</h3><p>跳表：将有序链表改成位支持近似二分法查找算法，可以进入快速的插入、删除、查找操作。    </p>
<p><img src="/RobertBlog/.io//image-20220813192626832-16603899882524.png" alt="image-20220813192626832"></p>
<h3 id="4、Redis-Key过期了为什么内存没释放？"><a href="#4、Redis-Key过期了为什么内存没释放？" class="headerlink" title="4、Redis Key过期了为什么内存没释放？"></a>4、Redis Key过期了为什么内存没释放？</h3><ol>
<li>手动修改过key的值，但是没有加上过期参数的话，那么这个key是永不过期。</li>
<li>Redis对于过期的Key的处理一般是惰性删除和定时删除策略：<ol>
<li>惰性删除：当读写一个已经过期的Key时，会触发惰性删除策略，判断Key是否过期，如果过期才会删除。</li>
<li>定时删除：由于惰性删除无法保证冷数据被及时删掉，所以Redis会定时主动淘汰一批过期的Key，但是并不是将所有的过期的Key都删除，所以可能还会出现过期的Key占据着内存。</li>
</ol>
</li>
</ol>
<h3 id="5、Redis-Key没有设置过期时间，为什么被Redis主动删除了？"><a href="#5、Redis-Key没有设置过期时间，为什么被Redis主动删除了？" class="headerlink" title="5、Redis Key没有设置过期时间，为什么被Redis主动删除了？"></a>5、Redis Key没有设置过期时间，为什么被Redis主动删除了？</h3><p>主动清理策略在Redis 4.0之前一共实现了6种内存淘汰策略，在4.0之后，又增加了2种策略，总共8种:</p>
<p>a) 针对设置了过期时间的key做处理:</p>
<p>volatile-ttl:在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。<br>volatile-random:就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。<br>volatile-Iru:会使用LRU算法筛选设置了过期时间的键值对删除。<br>volatile-lfu:会使用LFU算法筛选设置了过期时间的键值对删除。<br>b) 针对所有的key做处理(听上去有点不可思议):</p>
<p>allkeys-random:从所有键值对中随机选择并删除数据。<br>allkeys-Iru:使用LRU算法在所有数据中进行筛选删除。<br>allkeys-lfu:使用LFU算法在所有数据中进行筛选删除。<br>c) 不处理:</p>
<p>no-eviction:不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。<br>因此redis中key没有设置过期时间但被redis主动删除，有可能是因为redis的allkeys内存淘汰策略</p>
<p>另外对LRU算法和LFU算法做个补充说明：</p>
<p>LRU算法(Least Recently Used，最近最少使用):淘汰很久没被访问过的数据，以最近一次访问时间作为参考<br>LFU算法(Least Frequently Used，最不经常使用):淘汰最近一段时间被访问次数最少的数据，以次数作为参考<br>绝大多数情况我们都可以用LRU策略，当存在大量的热点缓存数据时，LFU可能更好点。</p>
<h3 id="6、Del-Key会阻塞Redis吗？"><a href="#6、Del-Key会阻塞Redis吗？" class="headerlink" title="6、Del Key会阻塞Redis吗？"></a>6、Del Key会阻塞Redis吗？</h3><p>会 删除不通类型的数据需要的时间不同。</p>
<h3 id="7、Redis-主从、哨兵，集群架构优缺点比较。"><a href="#7、Redis-主从、哨兵，集群架构优缺点比较。" class="headerlink" title="7、Redis 主从、哨兵，集群架构优缺点比较。"></a>7、Redis 主从、哨兵，集群架构优缺点比较。</h3><p>主从，需要人工拉起从节点。</p>
<p>哨兵架构：切换主从的过程中耗时；Redis 大小10G，数据大了影响恢复过程。</p>
<p><img src="/RobertBlog/.io//image-20220813202843304-16603937252815.png" alt="image-20220813202843304"></p>
<p>高可用集群模式：顺断问题比哨兵模式影响小。</p>
<p><img src="/RobertBlog/.io//image-20220813203136164-16603938985386.png" alt="image-20220813203136164"></p>
<h3 id="8、Redis集群数据Hash分片算法是怎么回事？"><a href="#8、Redis集群数据Hash分片算法是怎么回事？" class="headerlink" title="8、Redis集群数据Hash分片算法是怎么回事？"></a>8、Redis集群数据Hash分片算法是怎么回事？</h3><p>Redis Cluster 将所有数据划分为16384个槽位，每个系节点负责其中一部分槽位。槽位的信息存储与每个节点中</p>
<p>当Redis Cluster的客户端来连接集群时，它也会得到一份集群的槽位信心并将其缓存在客户端本地，这样找对用的Key时，可以根据槽位定位算法定位到目标节点。</p>
<p>槽位定位算法：Cluster 默认会对Key值使用crc16算法进行hash得到一个证书，然后用这个证书值对16384进行取模来得到具体槽位： Hash_slot = crc16(key) mod 16384。再根据槽位值和Redis节点对应的关系就可以定位到Key具体时落在那个Redis节点上。</p>
<h3 id="9、Redis执行命令有死循环bug"><a href="#9、Redis执行命令有死循环bug" class="headerlink" title="9、Redis执行命令有死循环bug"></a>9、Redis执行命令有死循环bug</h3><p>RandomKey 从当前数据库中随机返回一个 key，此命令在主节点上寻找key，并判断是否过期。过期的话就删除，继续寻找下一个Key，在主节点上执行还好，经过一段时间总能寻找到不过过期的Key。</p>
<p>但是在slave节点上执行的时候，slave节点上的del命令是只有主节点发送了del命令才能删除对应的Key，因此在主节点上执行RandomKey时候，无法删除过期的Key，由于从节点上大量的Key都过期，那么Slave就容易寻找不到符合条件的Key，陷入死循环。</p>
<p>这个是Redis的一个bug，在Redis 5.0才被修复，修复的方法在Slave节点上执行RandomKey限制执行次数，执行到一定次数后跳出循环。</p>
<h3 id="10、Redis主从切换导致缓存雪崩。"><a href="#10、Redis主从切换导致缓存雪崩。" class="headerlink" title="10、Redis主从切换导致缓存雪崩。"></a>10、Redis主从切换导致缓存雪崩。</h3><p>主动节点时间不一致，主节点比从节点慢。从节点切换成为主节点后，大量的Key过期，导致大量的请求直接访问数据库了，进而导致缓存雪崩。</p>
<h3 id="11、Redis-RDB、AOF"><a href="#11、Redis-RDB、AOF" class="headerlink" title="11、Redis RDB、AOF"></a>11、Redis RDB、AOF</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 300 50 <span class="comment">#300秒内执行了超过50key被改动，那么会dump文件。</span></span><br><span class="line">bgsave      <span class="comment">#异步，相比较于save，不会阻塞其他的Redis请求，采用的的是写实复制。</span></span><br></pre></td></tr></table></figure>

<p>RDB的缺点：会存在数据丢失。</p>
<p>AOF 模式：执行的命令追加到AOF的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always <span class="comment">#每个写命令都同步</span></span><br><span class="line">appendfsync everysec <span class="comment">#每秒同步一次</span></span><br><span class="line">appendfsync no <span class="comment">#让操作系统来决定何时同步</span></span><br></pre></td></tr></table></figure>

<p>缺点：恢复速度慢，体积大</p>
<p><img src="/RobertBlog/.io//image-20220813214806502-16603984884347.png" alt="image-20220813214806502"></p>
<h3 id="12、Redis主节点宕机导致数据全部丢失"><a href="#12、Redis主节点宕机导致数据全部丢失" class="headerlink" title="12、Redis主节点宕机导致数据全部丢失"></a>12、Redis主节点宕机导致数据全部丢失</h3><p><img src="/RobertBlog/.io//image-20220814120938172-16604501798318.png" alt="image-20220814120938172"></p>
<h3 id="13、Redis主从复制风暴："><a href="#13、Redis主从复制风暴：" class="headerlink" title="13、Redis主从复制风暴："></a>13、Redis主从复制风暴：</h3><p>Redis主节点有太多得从节点，导致主节点一直在向各个从节点同步数据，导致主节点压力比较大/</p>
<p>可以采用多级主从复制来规避此问题。</p>
<h3 id="14、Redis集群网络抖动导致频繁主从切换怎么处理？"><a href="#14、Redis集群网络抖动导致频繁主从切换怎么处理？" class="headerlink" title="14、Redis集群网络抖动导致频繁主从切换怎么处理？"></a>14、Redis集群网络抖动导致频繁主从切换怎么处理？</h3><p>可以配置cluster-node-timeout，较小集群对网络抖动得敏感度。</p>
<h3 id="15、Redis集群为什么是三个节点？"><a href="#15、Redis集群为什么是三个节点？" class="headerlink" title="15、Redis集群为什么是三个节点？"></a>15、Redis集群为什么是三个节点？</h3><p>因为Master得选举需要大于半数得集群master同意选举才能成功。</p>
<h3 id="16、Redis集群为什么是奇数节点？"><a href="#16、Redis集群为什么是奇数节点？" class="headerlink" title="16、Redis集群为什么是奇数节点？"></a>16、Redis集群为什么是奇数节点？</h3><p>奇数节点在master选举过程中比偶数节点能节省一个节点。</p>
<h3 id="17、Redis集群支持批量操作命令吗？"><a href="#17、Redis集群支持批量操作命令吗？" class="headerlink" title="17、Redis集群支持批量操作命令吗？"></a>17、Redis集群支持批量操作命令吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果直接操作mset，mget这样的原生批量操作命令，redis集群只支持所有的key在同一slot（插槽）上的情况，如果一定要批量操作可以在key前面加&#123;xxx&#125;，这样数据会根据参数分片算法计算括号内的值，这样才可以确保可以可以落到不同的slot当中</span><br><span class="line"></span><br><span class="line">mset &#123;user&#125;:1：name jack &#123;user&#125;:1:age 18</span><br></pre></td></tr></table></figure>

<h3 id="18、lua脚本可以在集群当中运行吗"><a href="#18、lua脚本可以在集群当中运行吗" class="headerlink" title="18、lua脚本可以在集群当中运行吗"></a>18、lua脚本可以在集群当中运行吗</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua脚本在集群当中运行，脚本里面操作redis的所有key必须在同一节点上，这种的话我们可以给lua脚本里面的key值前面都加上hash tag 也就是&#123;xxx&#125;，这样就可以保证脚本内的key都在同一个节点上</span><br></pre></td></tr></table></figure>

<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>1、怎么保证数据的一致性的：</p>
<ul>
<li>强一致性</li>
<li>弱一致性</li>
</ul>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="CAP理论："><a href="#CAP理论：" class="headerlink" title="CAP理论："></a>CAP理论：</h2><ul>
<li>Consistency（一致性）<ul>
<li>数据更新后并返回客户端，所有节点在同一时间的数据完全一致。对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，及如何复制分布到整个系统，以保证数据最终一致。</li>
</ul>
</li>
<li>Availability（可用性）<ul>
<li>服务高可用、正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</li>
</ul>
</li>
<li>Partition Tolerance（分区容错性）<ul>
<li>在分布式系统中遇到某个节点或者网络分区故障的时候，仍然能够对外满足一致性和可用性服务。</li>
</ul>
</li>
</ul>
<p>CP和AP：分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性只能2选1.</p>
<h2 id="BASE理论："><a href="#BASE理论：" class="headerlink" title="BASE理论："></a>BASE理论：</h2><p>BASE理论是基于CAP理论逐步演化而来的，是CP（强一致性）和AP（强可用性）权衡的结果。<br>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点采用适当的方式来使系统达到最终一致性。</p>
<h3 id="Basically-Available（基本可用）"><a href="#Basically-Available（基本可用）" class="headerlink" title="Basically Available（基本可用）"></a>Basically Available（基本可用）</h3><p>响应时间上的损失：正常情况下，处理用户请求需要0.5s返回结果，但是由于系统出现故障，处理用户请求的时间变3s。<br>系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的非核心功能无法使用。</p>
<h3 id="Soft-state（软状态）"><a href="#Soft-state（软状态）" class="headerlink" title="Soft state（软状态）"></a>Soft state（软状态）</h3><p>数据同步允许一定的延迟。</p>
<h3 id="Eventually-consistent（最终一致性）"><a href="#Eventually-consistent（最终一致性）" class="headerlink" title="Eventually consistent（最终一致性）"></a>Eventually consistent（最终一致性）</h3><p>系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要求实时。</p>
<h2 id="分布式Id的生成方案："><a href="#分布式Id的生成方案：" class="headerlink" title="分布式Id的生成方案："></a>分布式Id的生成方案：</h2><h3 id="UUID："><a href="#UUID：" class="headerlink" title="UUID："></a>UUID：</h3><ol>
<li>时间 时间戳</li>
<li>时钟序列 计数器</li>
<li>全局唯一的机器识别号，如果有网卡，从网卡的MAC地址获取，没有的话从其他的方式获取。</li>
</ol>
<ul>
<li>优点：代码简单，性能好，保证唯一</li>
<li>缺点：UUID是无序的，不是全数字，无法保证趋势递增；UUID生成的字符串，字符串存储性能差，查询效率慢，写的时候不能产生顺序的append操作，需要进行insert操作，导致频繁的也分裂，这种操作在记录占用空间比较大的情况下，性能下降比较大，还会增加读取磁盘次数；UUID长度过长，不适用于存储，耗费数据库性能；ID无一定业务含义，可读性差；有信息安全问题，可能邪路MAC地址。</li>
</ul>
<h3 id="数据库自增序列："><a href="#数据库自增序列：" class="headerlink" title="数据库自增序列："></a>数据库自增序列：</h3><p>单机模式：</p>
<ul>
<li>优点：实现简单，依靠数据库即可，成本小；ID数字化，单调自增，满足数据存储和查询性能。具有一定的业务可读性。</li>
<li>缺点：强依赖DB，存在单点问题，如果数据库宕机，则业务不可用；DB生成ID性能有限，单点数据库压力大，无法使用高并发场景。信息安全问题，暴露订单量，url查询改一下id查询到别人的订单。</li>
</ul>
<p>数据库高可用：多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大于节点数。</p>
<ul>
<li>优点：解决了ID生成单点问题，同时平衡了负载。</li>
<li>缺点：系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难；数据库压力大：每次扩区一个ID都必须读写一次数据库。主从同步的时候，数据一致性问题。</li>
</ul>
<h3 id="Leaf-segment："><a href="#Leaf-segment：" class="headerlink" title="Leaf-segment："></a>Leaf-segment：</h3><p>采用每次获取一个ID区间段的方式解决问题，可以一定程度上减轻数据库压力。</p>
<ul>
<li>优点：扩张灵活，性能强能够支撑起大部分业务场景，ID是趋势递增的，满足数据存储和查询性能要求。可用性高，即使ID生成服务器不可用，也能够保证业务短时间内可用。</li>
<li>缺点：可能存在多个节点同事请求ID区间的情况，依赖DB</li>
</ul>
<p>双Buffer模式：将获取一个号段的方式优化成获取两个号段，在一个号段用完后不用立马去更新号段。在当前号段使用10%的情况下，去查询下一个号段是否准备好，如果没有就提前去准备。</p>
<ul>
<li>优点：基于JVM存储双buffer的号段，减少了数据库查询，减少了网络依赖，效率更高。</li>
<li>缺点：segment 号段长度固定的，业务量大师可能会频繁更新号段。因为原本分配的号段会以下用完。其他的节点重新获取相之前的号段，跨度可能会大。</li>
</ul>
<p>基于Redis、MongoDB、zk等中间件完成。</p>
<h3 id="雪花算法："><a href="#雪花算法：" class="headerlink" title="雪花算法："></a>雪花算法：</h3><p>生成一个64bit的整形数字。第一位符号固定为0，41位为时间戳，10位workId，12位序列号。</p>
<ul>
<li>优点：每个毫秒值包含的ID值很多。不够可以编订位数来增加。时间戳在高位，中尉使固定的机器码，自增的在学列号地位，整个ID使趋势递增。能够根据业务场景数据库节点不知灵活挑战bit位划分，灵活度高。</li>
<li>缺点：强依赖与机器时钟，如果时钟回拨，会导致重复的ID生成，所以一般基于此的算法发现时钟回拨，都会跑异常处理，阻止ID胜场，可能或导致业务不可用。</li>
</ul>
<h2 id="分布式缓存寻址算法："><a href="#分布式缓存寻址算法：" class="headerlink" title="分布式缓存寻址算法："></a>分布式缓存寻址算法：</h2><ol>
<li><p>HASE算法：根据key进行hash运算，结果对分片数取模，确定分片适合固定分片数的场景。扩展分片或者减少分片时，所有数据都需要重新计算分片，存储。</p>
</li>
<li><p>一致性Hash：将整个Hash值得区间组成一个闭合圆环，计算每台服务器的Hash值，映射到圆环中。使用相同得Hash算法计算数据的Hash值，映射到圆环，顺时针寻找，找到第一个服务器的数据存储的服务器。</p>
<p>新增及减少节点时只会影响节点到其他逆时针最近的一个服务器之间的值。存在hash环倾斜问题，服务器分布不均匀，可以通过虚拟节点解决。</p>
</li>
<li><p>hash slot：将数据和服务器隔开。数据与slot映射，slot与服务器映射，数据进行hash决定存放slot，新增节点或者删除节点，只需要将slot进行迁移即可。</p>
</li>
</ol>
<h2 id="分布式架构下，Session共享有什么方案？"><a href="#分布式架构下，Session共享有什么方案？" class="headerlink" title="分布式架构下，Session共享有什么方案？"></a>分布式架构下，Session共享有什么方案？</h2><ol>
<li><p>启用Session，采用无状态服务。</p>
</li>
<li><p>客户端存储cookie，有安全风险。</p>
</li>
<li><p>服务器之间同步session，但是存在同步延迟的问题。</p>
</li>
<li><p>IP绑定策略，同一个ip只能访问固定的服务端。</p>
</li>
<li><p>使用Redis存储。</p>
<p>把Session放到Redis中存储，虽然架构商变得服务，并且需要多访问一次Redis，但是这种方案带来的好处时很大的：</p>
<p>实现Session共享，可以水平扩展，服务器重启Session不丢失，不仅可以跨服务器Session共享，甚至可以跨平台。</p>
</li>
</ol>
<h2 id="分布式事务："><a href="#分布式事务：" class="headerlink" title="分布式事务："></a>分布式事务：</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183753774">https://zhuanlan.zhihu.com/p/183753774</a></p>
<h2 id="分布式锁的解决方案："><a href="#分布式锁的解决方案：" class="headerlink" title="分布式锁的解决方案："></a>分布式锁的解决方案：</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42440011/article/details/116998915">https://blog.csdn.net/weixin_42440011/article/details/116998915</a></p>
<h2 id="分布式负载均衡的策略有哪些："><a href="#分布式负载均衡的策略有哪些：" class="headerlink" title="分布式负载均衡的策略有哪些："></a>分布式负载均衡的策略有哪些：</h2><ol>
<li>轮询法</li>
<li>加权轮询法，给抗压能力强的节点更高的权重。</li>
<li>随机法</li>
<li>加权随机法</li>
<li>源地址哈希法，根据客户端IP地址，hash运算出固定访问某一台服务端。</li>
<li>最小连接法。根据后端服务器连接情况，分配给连接数最小的服务端。</li>
</ol>
<p>集群、分布式、SOA、微服务的概念区别。</p>
<p>分布式：不同模块部署在不同服务器上<br>作用：分布式解决网站高并发带来问题</p>
<p>集群：多台服务器部署相同应用构成一个集群<br>作用：通过负载均衡设备共同对外提供服务</p>
<p>SOA：业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力，通过服务的组合和编排来实现上层的业务流程<br>作用：简化维护,降低整体风险,伸缩灵活</p>
<p>微服务：架构设计概念,各服务间隔离（分布式也是隔离）,自治（分布式依赖整体组合）其它特性(单一职责,边界,异步通信,独立部署)是分布式概念的跟严格执行SOA到微服务架构的演进过程<br>作用：各服务可独立应用，组合服务也可系统应用<br><img src="/RobertBlog/.io//image-20220815004202921-166049532581710.png" alt="image-20220815004202921"></p>
<h1 id="Java并发："><a href="#Java并发：" class="headerlink" title="Java并发："></a>Java并发：</h1><h2 id="1、CountDownLatch和Semaphore的区别和底层原理："><a href="#1、CountDownLatch和Semaphore的区别和底层原理：" class="headerlink" title="1、CountDownLatch和Semaphore的区别和底层原理："></a>1、CountDownLatch和Semaphore的区别和底层原理：</h2><p>CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用<code>CountDownLatch</code>的<code>await()</code>将会阻塞，其他的线程可以调用<code>CountDownLatch</code>的<code>countDown()</code>方法来对CountDown中的数字减一，当数字减小到0后，所有<code>await()</code>的线程都将会被唤醒。</p>
<ul>
<li>底层原理：调用await()方法的线程会利用AQS排队，一旦数字被减小为0，则会将AOS中排队的线程依次唤醒。</li>
</ul>
<p>Semaphore 表示的是信号量，可以设置许可的个数，表示同时最多允许多少个线程使用该信号量，通过acquire()来获取许可，如果没有许可的话线程将会阻塞，并通过AQS来排队，可以通过release()方法来释放许可，当某个线程释放许可后，就会从AQS队列中找到ige线程开始唤醒，直至没有许可。</p>
<h2 id="2、Java如何开始线程，怎么保证线程安全："><a href="#2、Java如何开始线程，怎么保证线程安全：" class="headerlink" title="2、Java如何开始线程，怎么保证线程安全："></a>2、Java如何开始线程，怎么保证线程安全：</h2><p>线程和进程关系：进程是操作系统分配资源的最小单元，线程是操作系统分配任务的最小单元，线程隶属进程。</p>
<ol>
<li>实现Thread类，重写run方法，调用start方法，启动多线程。</li>
<li>实现Runnable接口，实现run方法，创建接口实现类的对象，将对象作为参数传入Thread构造函数中，创建Thread对象，调用run方法。</li>
<li>实现Callable接口，实现call方法，创建接口实现类对象，创建FutureTask类对象，并将接口实现类的对象传入；将FutureTask实现类对象作为参数传入Thread类的构造器中，创建Thread类的对象，调用Start方法。</li>
<li>通过线程池来开启线程。</li>
</ol>
<p>怎么保证线程安全的问题：</p>
<p>加锁：1、JVM提供的锁synchronized关键字，1.5之前版本是重量锁，之后是清凉所。2、JDK提供的锁。</p>
<h3 id="延申：锁分类"><a href="#延申：锁分类" class="headerlink" title="延申：锁分类"></a>延申：锁分类</h3><h4 id="悲观锁、乐观锁"><a href="#悲观锁、乐观锁" class="headerlink" title="悲观锁、乐观锁"></a>悲观锁、乐观锁</h4><ul>
<li>悲观锁：认为别人肯定会跟自己抢资源，并且抢到的机率比较大，因此在操作之前，必须进行加锁的操作。</li>
<li>乐观锁：认为遭遇并发的机率比较低，读数据时不会有人修改数据，不加锁直接读，写数据的时候泽在进行更新之前判断数据是否已经被修改，如果没有被修改过则更新，修改过则放弃更新。</li>
</ul>
<h4 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h4><ul>
<li>独占锁：一个锁只能由一个线程持有，独占锁是一种悲观策略，较坏的情况如果某个只读线程获取到锁，那么其他只读线程也只能等待，限制了并发性，因为读操作并不会影响数据一致性。典型的是ReentrantLock。</li>
<li>共享锁：共享锁放宽了加锁限制，允许多个只读线程同时获取锁，并发访问资源。共享锁不适合写线程。</li>
</ul>
<h4 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h4><ul>
<li>java提供了读写锁，在读的地方使用读锁(共享锁)，在写的地方使用写锁(独占锁)。读之间不互斥，读写与写写之间互斥。在没有写的情形下，读是无阻塞的，一定程度上提高了同时存在读写场景的并发性。<br>java提供了读写锁的接口java.util.concurrent.locks.ReadWriteLock，可以实现这个接口完成自己的读写锁。也可以使用已有的实现ReentrantReadWriteLock.</li>
</ul>
<h4 id="公平锁与非公平锁："><a href="#公平锁与非公平锁：" class="headerlink" title="公平锁与非公平锁："></a>公平锁与非公平锁：</h4><ul>
<li>公平锁：公平锁在加锁之前会检查是否已有在等待的线程，如果有则优先已等待的线程。换一种方式表述就是线程排排队，先到先得，每一个尝试获得锁的线程都会被放到等待队列中，当锁资源释放后，最先等待的线程先拿到锁。</li>
<li>非公平锁：非公平锁不考虑先来后到的问题，线程直接去尝试获取锁，而不会管之前是否已经有线程处于等待状态了。获取失败则进入等待队列等待。</li>
</ul>
<p>公平锁要维护队列，但是其实非公平锁也是会维护队列或集合的，只是非公平锁无需严格遵守队列顺序，因此高效的本质还是在于非公平锁的闯入机制，也就是一个新的线程获取锁时会直接尝试获取锁，失败才进入队列，而不是直接进入队列等待。这样就可以充分利用锁释放后，队列首部的线程重新尝试获取锁这一段时间。<br>公平锁模式下锁释放后需要唤醒队列首部的线程，而从阻塞到运行需要完成内核态到用户态的切换，这是一个很耗时的过程，那么在切换状态的期间就会处于无线程实际运行的情况，大大的浪费了资源。而在这个过程中允许闯入线程获取锁就能很好的利用这一段空白时间。</p>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁，又可以称为递归锁，指的是一个线程在持有锁的情况下，可以再次获取锁而不受影响。ReentrantLock和synchronized都是可重入锁。</p>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><p>分段锁是一种概念，即将资源拆分成数断，将对整个资源的锁定改为对一段资源的锁定，提高并发性能。JDK1.8之前的<a target="_blank" rel="noopener" href="https://blog.csdn.net/yue_hu/article/details/113754357">ConcurrentHashMap</a>是典型的分段锁实现。JDK1.8开始<a target="_blank" rel="noopener" href="https://blog.csdn.net/yue_hu/article/details/113754357">ConcurrentHashMap</a>舍弃了分段锁，改用用自旋+CAS+<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=sync&spm=1001.2101.3001.7020">sync</a>关键字来实现同步。</p>
<h4 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h4><p>在介绍自旋这个概念之前首先说一下内核态和用户态的概念。简单的说运行操作系统的程序(如操作硬件)需要在内核态（Kernel Mode）进行，用户态（User Mode）则用来运行用户程序。而阻塞等待动作即需要在内核态完成。<br>一个线程，线程阻塞从运行状态进入阻塞状态需要从用户态进入内核态，线程唤醒从阻塞状态进入运行状态则需要从内核态恢复到用户态。而线程状态之前的切换需要的成本非常高，需要的时间也很长。<br>在多个线程竞争同一个锁的场景下，一个线程获取锁之后，其它线程得不到锁就需要进入阻塞状态进行一个用户态到内核态的转变，而当锁资源释放时又需要唤醒线程进行一个内核态到用户态的转变。但是如果持有锁的线程能很快的释放锁，就可能会出现线程等待锁释放的代价要比线程经历两次状态切换的代价更低。<br>自旋的操作就被提出了：如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，他们只需要等一等(自旋)，等待有锁的线程释放锁之后即可立即获取锁，这样就避免了线程状态切换的消耗</p>
<h4 id="无锁-amp-偏向锁-amp-轻量级锁-amp-重量级锁："><a href="#无锁-amp-偏向锁-amp-轻量级锁-amp-重量级锁：" class="headerlink" title="无锁&amp;偏向锁&amp;轻量级锁&amp;重量级锁："></a>无锁&amp;偏向锁&amp;轻量级锁&amp;重量级锁：</h4><p>可以通过设置JVM参数UseHeavyMonitors禁用偏向锁和轻量锁，直接使用重量锁。<br>在了解锁膨胀之前先了解一下锁膨胀实现的关键：位于Java对象头中的Mark Word.</p>
<p>上图即为堆中一个对象组成的简单结构，Mark Word所处的位置已用蓝色标出，灰色部分与锁无关。JAVA对象头一般由两个机器码组成，Mark Word和类型指针各占据一个，如果是数组对象则会多出一个机器码用来维护数组长度以便JVM确认数组大小。<br>Mark Word用来存储对象运行时数据，如identityHashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向ID等。以32位JVM为例，一个机器码4个字节，即32bit。32bit自然无法存储Mark Word要存的所有内容，因此会复用存储空间，对象处于不同的状态，Mark Word内存的内容也会不同，不同状态下存储的内容如图：</p>
<p><img src="/RobertBlog/.io//watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeXVlX2h1,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.png" alt="Java锁"></p>
<p>其中需要重点关注的地方用蓝色底色标出，结合这个图片能更好的理解锁膨胀过程中的各个阶段。<br><img src="/RobertBlog/.io//image-20220816004015828-16605816171142.png" alt="image-20220816004015828"></p>
<h2 id="3、ReebtrantLock的lock-和tryLock"><a href="#3、ReebtrantLock的lock-和tryLock" class="headerlink" title="3、ReebtrantLock的lock()和tryLock()"></a>3、ReebtrantLock的lock()和tryLock()</h2><p>是一个可重用锁、非公平锁。</p>
<ul>
<li>lock()，是一个阻塞加锁的过程，方法会阻塞当前线程直到拿到锁。</li>
<li>tryLock()是一个非阻塞，是否加到锁会返回一个boolen值。</li>
</ul>
<h2 id="4、并发、并行、串行、指令重排"><a href="#4、并发、并行、串行、指令重排" class="headerlink" title="4、并发、并行、串行、指令重排"></a>4、并发、并行、串行、指令重排</h2><ul>
<li>串行：任务一个一个完成。</li>
<li>并行：多个任务同时在进行，在CPU执行上是一个任务依次执行的。</li>
<li>并发：多个任务同时发起，但是在CPU上是通过不断切换线程，来达到多个任务都在进行。</li>
</ul>
<p>并发三大特性：</p>
<ul>
<li>原子性：</li>
<li>可见性：多线程情况下，多线程之间共享的值的改变可以同时可见。</li>
<li>有序性：</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://robert-pf.github.io/RobertBlog/2022/04/12/%E7%AC%94%E8%AE%B0/" data-id="cl6w6pzid0004k4igaqb82208" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/RobertBlog/2022/05/12/idea%E4%BD%BF%E7%94%A8%E4%B9%8B%E8%B0%9C/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          idea
        
      </div>
    </a>
  
  
    <a href="/RobertBlog/2022/03/31/Linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/Java-Spring/" rel="tag">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/Java-Web/" rel="tag">Java Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/LVM/" rel="tag">LVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/MongoDB%E9%9B%86%E7%BE%A4/" rel="tag">MongoDB集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/Web%E7%BD%91%E9%A1%B5/" rel="tag">Web网页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/idea-java/" rel="tag">idea java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/RobertBlog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/RobertBlog/tags/Java-Spring/" style="font-size: 20px;">Java Spring</a> <a href="/RobertBlog/tags/Java-Web/" style="font-size: 10px;">Java Web</a> <a href="/RobertBlog/tags/LVM/" style="font-size: 20px;">LVM</a> <a href="/RobertBlog/tags/MongoDB/" style="font-size: 20px;">MongoDB</a> <a href="/RobertBlog/tags/MongoDB%E9%9B%86%E7%BE%A4/" style="font-size: 10px;">MongoDB集群</a> <a href="/RobertBlog/tags/MyBatis/" style="font-size: 20px;">MyBatis</a> <a href="/RobertBlog/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/RobertBlog/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/RobertBlog/tags/Web%E7%BD%91%E9%A1%B5/" style="font-size: 10px;">Web网页</a> <a href="/RobertBlog/tags/idea-java/" style="font-size: 10px;">idea java</a> <a href="/RobertBlog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RobertBlog/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/RobertBlog/2022/07/29/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/">(no title)</a>
          </li>
        
          <li>
            <a href="/RobertBlog/2022/07/17/IO%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/RobertBlog/2022/05/12/idea%E4%BD%BF%E7%94%A8%E4%B9%8B%E8%B0%9C/">idea</a>
          </li>
        
          <li>
            <a href="/RobertBlog/2022/04/12/%E7%AC%94%E8%AE%B0/">Java 面试题整理笔记</a>
          </li>
        
          <li>
            <a href="/RobertBlog/2022/03/31/Linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Robert Pang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/RobertBlog/" class="mobile-nav-link">Home</a>
  
    <a href="/RobertBlog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/RobertBlog/fancybox/jquery.fancybox.css">

  
<script src="/RobertBlog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/RobertBlog/js/script.js"></script>




  </div>
</body>
</html>